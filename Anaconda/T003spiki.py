sp = [(int(input()), int(input())), (int(input()), int(input())),
      (int(input()), int(input())), ]
# sp = [(1,13), (11,20), (30,40)]
# sp = [(0,2), (4,5), (3,6)]
# sp = [(1,5), (0,1), (4,8)]
# sp = [(1,100), (2,5), (10,14)]


def te(st, s1, s2):
    if s1[0] > s2[0]:
        # s1 ближняя к 0, s2 - дальняя
        s1, s2 = s2, s1
    # s1 и s2 пересекаются
    if s1[1] >= s2[0]:
        return True
    # зазор между s1 и s2 меньше длины st
    if s2[0] - s1[1] <= abs(st[1] - st[0]):
        return True

# предположим, что l r могут быть перепутаны ?
sp = [(l, r) if l < r else (r, l) for l, r in sp]

spS = sorted(sp)
# спички пересекаются попарно или ближняя к 0 очень большая
if spS[0][1] >= spS[1][0] and spS[1][1] >= spS[2][0] or \
   spS[0][1] >= max(spS[1][0], spS[2][1]):
    print('0')
else:
    if te(sp[0], sp[1], sp[2]):
        print('1')
    elif te(sp[1], sp[0], sp[2]):
        print('2')
    elif te(sp[2], sp[0], sp[1]):
        print('3')
    else:
        print('-1')


'''
Вдоль прямой выложены три спички. Необходимо переложить одну из них,
чтобы при поджигании любой спички сгорали все три.
необходимо чтобы эти спички соприкасались (хотя бы концами).

Вводятся шесть целых чисел : l₁, r₁, l₂, r₂, l₃, r₃ –
координаты спичек соответственно (0 ≤ lᵢ < rᵢ ≤ 100).
Каждая спичка описывается координатами левого и правого концов по оси OX.

Выведите номер искомой спички.
Если возможных ответов несколько,
то выведите наименьший по номеру спички).
В случае, когда нет необходимости перемещать какую-либо спичку, выведите 0.
Если же требуемого результата достигнуть невозможно, то выведите -1.
'''
